// prisma/schema.prisma

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum DocumentKind {
  TAILORED_RESUME
  CREATED_RESUME
  COVER_LETTER
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  CANCELED
}

model User {
  id                  String   @id @default(cuid())
  name                String?
  email               String?  @unique
  passwordHash        String?
  emailVerified       DateTime?
  image               String?
  credits             Int      @default(0)
  onboardingComplete  Boolean  @default(false)
  // Added new changes

  // relations
  sessions      Session[]
  documents     Document[]
  purchases     Purchase[]
  verifications EmailVerification[]
  resets        PasswordReset[]
  oauthAccounts OAuthAccount[]
  profile       Profile?  // ðŸ‘ˆ 1â€“1 profile

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Profile {
  id               String  @id @default(cuid())
  userId           String  @unique
  // basics
  headline         String?      // e.g., "Software Developer"
  location         String?
  phone            String?
  website          String?
  linkedInUrl      String?
  // education
  school           String?
  degree           String?
  graduationYear   String?
  // skills & prefs
  skills           Json?        // string[]
  targetRoles      String?
  targetLocations  String?
  jobType          String?      // "Full-time" | "Part-time" | ...
  // metadata
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user             User    @relation(fields: [userId], references: [id])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique             // opaque session token
  expires   DateTime
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([expires])
}

model Document {
  id         String       @id @default(cuid())
  userId     String
  kind       DocumentKind
  title      String       @default("")
  markdown   String                       // full content
  sections   Json                         // parsed sections for editor/preview
  sourceMeta Json?                        // snapshot of jd/resume/env

  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  user       User         @relation(fields: [userId], references: [id])
  @@index([userId, kind, createdAt])
}

model Purchase {
  id           String        @id @default(cuid())
  userId       String
  provider     String        @default("PESEPAY") // keep simple, future providers optional
  amount       Int                           // minor units (e.g., cents)
  currency     String        @default("USD")
  credits      Int                           // how many credits this purchase grants
  status       PaymentStatus @default(PENDING)
  providerRef  String?       @unique         // e.g., pesepay reference/transaction id
  meta         Json?                         // raw payloads / fields from provider

  createdAt    DateTime      @default(now())
  user         User          @relation(fields: [userId], references: [id])

  @@index([userId, createdAt])
  @@index([status])
}

/** Email verification flow (code-based or link-based) **/
model EmailVerification {
  id         String   @id @default(cuid())
  userId     String
  email      String
  // Either store a 6-digit code (hashed) or a random token (hashed). Weâ€™ll use codeHash for MVP.
  codeHash   String
  expiresAt  DateTime
  consumedAt DateTime?

  user       User     @relation(fields: [userId], references: [id])

  @@index([userId, expiresAt])
  @@index([email])
}

/** Password reset via token (optional but handy) **/
model PasswordReset {
  id         String   @id @default(cuid())
  userId     String
  tokenHash  String
  expiresAt  DateTime
  usedAt     DateTime?

  user       User     @relation(fields: [userId], references: [id])

  @@index([userId, expiresAt])
}

/** Optional future: OAuth accounts (keeps door open for Google later) **/
model OAuthAccount {
  id                String  @id @default(cuid())
  userId            String
  provider          String
  providerAccountId String

  accessToken       String?
  refreshToken      String?
  expiresAt         Int?

  user              User    @relation(fields: [userId], references: [id])

  @@unique([provider, providerAccountId])
  @@index([userId])
}
